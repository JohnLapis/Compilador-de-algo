#+property: header-args :tangle Scanner.java :comments link

* bnf
** https://www.ccs.neu.edu/home/dherman/javascript/
** https://tomcopeland.blogs.com/EcmaScript.html
** https://www.ecma-international.org/ecma-262/11.0/index.html#sec-names-and-keywords
* imports
#+begin_src java :noweb-ref imports
package compilador;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
#+end_src

* general notes
:PROPERTIES:
:header-args: :tangle   no
:END:
- https://github.com/tc39/test262/tree/main/src
- https://www.ecma-international.org/ecma-262/11.0/index.html#sec-grammar-summary

- token
  #+begin_src js
    commonToken = (IdentifierName | Punctuator | NumericLiteral | StringLiteral | Template)

    IdentifierName = IdentifierStart+IdentifierPart
    IdentifierStart = [$_\\]

    IdentifierStart = UnicodeIDStart $ _ \UnicodeEscapeSequence
    IdentifierPart = UnicodeIDContinue $ \UnicodeEscapeSequence <ZWNJ> <ZWJ>

  UnicodeIDStart::
    any Unicode code point with the Unicode property “ID_Start”
    UnicodeIDContinue::
    any Unicode code point with the Unicode property “ID_Continue”
    Punctuator
    NumericLiteral
    StringLiteral
    Template
  #+end_src
- keyword
  $note: all keywords are valid identifier_names
  #+begin_src js
  await | break | case | catch | class | const | continue | debugger | default | delete | do | else | enum | export | extends | false | finally | for | function | if | import | ininstance | of | new | null | return | super | switch | this | throw | true | try | typeof | var | void | while | with | yield
  #+end_src
- puncturator
  #+begin_src js
  (OptionalChainingPunctuator | OtherPunctuator)
  Optio
nalChainingPunctuator = \?\.(?!=(?DECIMAL DIGIT))
  Other
Punctuator =
[ { ( ) [ ] . . . . ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? ?? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => ]
  DivPu
nctuator (/|/=)
  RightBracePunctuator = }
  #+end_src
- WhiteSpace
  #+begin_src js
  [\u0009 \u000B \u000C \u0020 \u00A0 \uFEFF]
  whitespace = \s # check all characters possible
  Code
Point	Name	Abbreviation
  U+0009	CHARACTER TABULATION	<TAB>
  U+000B	LINE TABULATION	<VT>
  U+000C	FORM FEED (FF)	<FF>
  U+0020	SPACE	<SP>
  U+00A0	NO-BREAK SPACE	<NBSP>
  U+FEFF
  #+end_src
- LineTerminator
  #+begin_src js
  Terminator  = (LineTerminator|LineTerminatorSequence)
  LineTerminator = (<LF> | <CR> | <LS> | <PS> )
  LineTerminatorSequence = (<LF> | (?=>CR) <CR>(?!=<LF>) ] | <LS> | <PS> | <CR><LF>)
  #+end_src
- All "
kinds" of tokens are either keywords identifiernames and special symbols
- keywords is a subset of identifiernames
- space should be ignored completely
  + ex: imagine you write ~varname = ...~ it should pass the scanner
- the biggest problem is the special characters
- maybe

 put those in a enum in the class
- read more the tables in oracle for syntax you still don't know
- string literals will be handled later (quotes are a differente case form ())
** ! Wh
ich exceptions should be thrown? Myb create a custom one
** ! ArrayList initial capacity is 10. It maybe should set higher.
** Create your own templates then.
If it's within {} and it's not escaped, get its position + around braces and
replace it with the variable (of course, put this into a function)
** ! who should say if asdf645 is valid??? the parser
** ! decimal literal try
> "111_111_".match(/\d{1,3}(_(?=\d{3}(_|$))\d+)*/)
** ! optimizing regexes
- how are they matched? if alphanums are matched using ranges of the unicode,
  then ~[a-zA-Z]~ is faster than ~[asdfb'@$650056#ffs]~
- should i put this comment?
  #+begin_quote
  // They are in increasing order of size of the set of matchable characters
  #+end_quote
  well, it looks almost certain that the ~SPECIAL_TOKEN~ requires more
  comparisons and should be last
- check
 the thing with line terminators later because it is less relevant
  + dealing with unicode characters is more complicated
** ! ECMAScript uses Unicode@v13 and Java@11 uses version 10
Do a sanity check later with that information. The places where this could go
wrong is with big sets (like with IDENTIFIER_NAME)
#+begin_src js :tangle no
//     String U_OPERATORS[] = {"-", "~", "++", "--",}
// Pattern OPERATOR = Pattern.compile("(" + String.join("|", OPERATORS) + ")")
// Pattern NUMBER = Pattern.compile("[+-]?\d+(\.\d)?")
// PatLiteral
Pattern Literal	=	( <DECIMAL_LITERAL> | <HEX_INTEGER_LITERAL> | <STRING_LITERAL> | <BOOLEAN_LITERAL> | <NULL_LITERAL> | <REGULAR_EXPRESSION_LITERAL> )tern pattern = Pattern.compile("((?NUMBER)|(?IDENTIFIER)|(?OPERATOR))");
String
OPERATOR = "=|\+|-|/|<|>|>>|<<|<=|>=|===|!=|!==|\|\||&";
String DECIMAL_NUMBER = "[+-]?\\d+(\\.\\d)?";
// Can
i call it an expressoin???
// It's still not compled because it's "templated"
String LINE_TERMINATOR = "$"
String EXPRESSION = "({OPERATOR}|{LITERAL}|{IDENTIFIER_NAME})*LINE_TERMINATOR";
// Alte
rnative to EXPRESSION
// it's the parser that decides if > is followed by another > or not
// @ e ^??     e #???

#+end_src
** ! [#A] adding a catch all regex for "unidentified token"
in case a sequence of characters isn't matched by any of the valid sequences
expressed via the regexes, there's a "unidentified-token" error. And care should be taken to
avoid matching useless characters like whitespace, line terminators, etc.
** ! create tests for invalid input
** ! pass some of the checking to the parser
That's something quite obvious but it isn't so clear where to draw the line in
specific cases. But it is important to know we have two passes to parse the
code.

Considering this, it might even be useful to simplify the rules of the scanner.
E.g., leaving to the parser the prohibition of certain characters while having a
high level stuff in the scanner. However, the scanner shouldn't be deceived so
much.
** ! on escaping sequences
- some wrong escseq (escaping sequences) are still valid code and there's
  "nothing" to do about it
- lazy matching is the best option for avoiding sequences from continuing after
  their end
- the important part is to allow the "prohibited" characters to be matched
  within the regex. So the idea is to have general structs with their
  appropriate rules, and then just add at the end the option for escaping. And
  those options should encompass the appropriate rules
- An idea is to create a func ~makeRegexEscape()~ which returns the regex for
  escaping the chars given in the arguments.
- the focus is to have everything working most of the time and perfecting it
  later
- optimization comes at the end. Now is not the time.
- this will make it possible to avoid some ~[^foo]~'s
- i could also just substitute the unicode code point before scanning, but
  that's gonan be clearer later
* code
** tokenizer_start
#+begin_src java :noweb-ref tokenizer_start
class Scanner {
    public enum Keywords {};

    public static List<String> tokenize(String code) throws ParseException {
        /**
         * The matching is eager, so, if there's a character that could be
         * repeated (like '>' and '>>' or '*' and '**') as a token, a single
         * token of the repeated character will be matched instead of many
         * tokens of a single character.
         *
         * And they are in order of priority. Ex: matching '!=' has higher
         * precedence than '!'. Resulting in '!=' instead of '!', '='.
         */
#+end_src

** _COMMENTS
#+begin_src java :noweb-ref COMMENT
// Only multiline comments are matched with the DOTALL flag.
String COMMENT = "(?s:/\\*.*?\\*/)|//.*";
#+end_src

** PUNCTUATOR
#+begin_src java :noweb-ref SPECIAL_TOKEN
String PUNCTUATOR =
    String.join("|",
                // Special handlings
                "!==?|!|\\?(\\.(?=\\D)|\\?)?",
                // Single punctuators
                "\\(|\\)|\\[|\\]|\\{|\\}|,|\\.(\\.{2})?|;|:|~|\\",
                // Punctuators with '='
                "(\\+|-|\\*{1,2}|/|%|<{1,2}|>{1,3}|^|&|\\|)=|=>|={1,3}",
                // Punctuators which may have repeatable character
                "\\+{1,2}|\\-{1,2}|\\*{1,2}|%|/|>{1,3}|<{1,2}|&{1,2}|\\|{1,2}"
                );
#+end_src

** LINE_TERMINATOR
#+begin_src java :noweb-ref LINE_TERMINATOR
/**
 * The LINE_TERMINATOR possible characters are:
 * U+000A	LINE FEED (LF)	<LF>
 * U+000D	CARRIAGE RETURN <CR>
 * U+2028	LINE SEPARATOR	<LS>
 * U+2029 PARAGRAPH SEPARATOR <PS>
 *
 * <CR> followed by <LF> is considered token for better reporting of
 * line numbers.
 */
String LINE_TERMINATOR = "\\u000A+|\\000D+|\\u2028+|\\u2029+";
#+end_src

- deal with Pattern Syntax and Whitespace Pattern Syntax Later
#+begin_quote
- ID_Start
Unicode General_Category of...
uppercase letters, lowercase letters, titlecase letters, modifier letters, other letters, letter numbers, plus Other_ID_Start,
\p{L}             \p{Nl}                                                                                 \p{Other_ID_Start}

minus Pattern_Syntax and Pattern_White_Space code points.
-     \p{Pattern_Syntax} -  \p{Pattern_White_Space}]


ID_Continue	ID_Continue characters include ID_Start characters, plus characters having the Unicode General_Category of nonspacing marks, spacing combining marks, decimal number, connector punctuation, plus Other_ID_Continue , minus Pattern_Syntax and Pattern_White_Space code points.
In set notation:
[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]


- [-] some line terminator matching is made implicitly by the fact that ~.~ doesn't
  match line terminators. However, the line terminators it doesn't match should
  be checked agains the line terminators determined by ECMAScript

  Have a look at java's ~\R~ (it's only a slight superset of the ecmascript line
  term.)
#+end_quote
** LITERAL
- [-] they can be followed only (i think) by line terminal, punctuator,
  whitespace, comments
- [-] just make it work most of the time and then perfect that later
#+begin_src java :noweb-ref LITERAL
String CHARATER_ESCAPE_SEQUENCE =
    String.join("|",
                "[^" + LINE_TERMINATOR + "\\dxu]",
                "0(?!\\d)",
                "x[0-9a-fA-F]{2}",
                "u([0-9a-fA-F]{4}|)"
                );
/**
 * - Numeric literals are case-insensitive.
 *
 * - All literals have a word boundary between them and any other token.
 *
 * - The sign before the number acts as a operator regardless if there's
 * just one number.
 *
 * - Many operators are lazy (with "?" at the end) because many of the
 * - characters possible inside a literal are also possible outside it.
 * - Therefore, unless it is matched in the regex with an escape ("\")
 * - it'll define the end of the literal.
 */
String LITERAL =
    String.join("|",
                // Decimal literal
                /**
                 * If starts with [1-9] digit, is followed by 0 or
                 * more digits, an optional dot, and more digits after
                 * the dot. The first '[0-9]*' consumes all digits if
                 * there's no digit after the dot, and the matching of
                 * the number remains consistent without any
                 * lookbackward checing.
                 *
                 * If starts with a dot, is followed by 1 or more digits.
                 *
                 * In both cases, the exponential part is optional.
                 */
                "(([1-9][0-9]*\\.?[0-9]*)|(\\.[0-9]+))([eE][+-]?[0-9]+)?",
                // Big integer decimal literal
                "(0|[1-9][0-9]*)n",
                // Binary literal
                "0[bB][01]+n?",
                // Octal literal
                "0[oO][0-7]+n?",
                // Hexadecimal literal
                "0[xX][0-9a-fA-F]+n?",
#+end_src

- [-] how far word boudaries (~\b~) go?
#+begin_src java :noweb-ref LITERAL
// String literal
/**
 * Each regex composing a string literal matches only
 * one character. The end result is that you have all
 * those possible characters being matched by the lazy
 * wildcard "*". And that's why it is wrapped in
 * parentheses.
 */
"['\"]("
// String literal: Prohibited characters
+ "[^\\u005c\\u000d\\u000a]"
// String literal: Line continuation
+ "|" + LINE_TERMINATOR + "(?<=\\)"
// String literal: Escape sequence
+ "|" + "\\" + CHARATER_ESCAPE_SEQUENCE
+ ")*?['\"]",
// Regex literal
/**
 * The sequence "//" isn't an empty regex literal,
 * it's comment.
 *
 * U+005C is a backslash, which doesn't conflict with
 * the non-literal dot following it.
 */
#+end_src

- [-] the regex flags should be optimized to match only IdentifierPart
#+begin_src java :noweb-ref LITERAL
// Regex literal: first character
"/([^\\*\\[/\\]|(\\u005c).+|\\[.*?\\])"
// Regex litreal: following characters
+ "/([^\\[/\\]|(\\u005c).+|\\[.*?\\])*?/",
#+end_src

- [-] where should the substitution of the template literal be? i think it's in
  the parser
#+begin_src java :noweb-ref LITERAL
// Template literal
"(?s:`([^`\\]|(\\u005c).+)*?`)"
);
#+end_src

** IDENTIFIER_NAME
- check how to convert the escape sequences to characters with utf-16
- where to convert the escapes? if the pattern is ~[\\u1166-3366]~ how to make
  it match that? myb there's a java function for automatically converting that
- check https://www.ecma-international.org/ecma-262/11.0/index.html#sec-utf16encode
- [-] add \\u[0-9a-f] support later

#+begin_src java :noweb-ref IDENTIFIER_NAME
/**
 * IDENTIFIER_NAME allows UnicodeEscapeSequences that, when replaced by
 * a SourceCharacter is still a valid IDENTIFIER_NAME. Ex: '\0061' is
 * valid because it represents the character 'e' and '\0025' is invalid
 * because it represents the character '%'.
 *
 * The code points U+200C and U+200D are named, respectively, <ZWNJ>, <ZWJ>.
 */
String IDENTIFIER_NAME =
    // Turn on Unicode_Character_Class flag
    "(?U)"
    // Valid starting character
    + "[\\p{L}\\p{Nl}]+"
    // Valid ending characters
    + "[\\p{L}\\p{Nl}\\u200c\\u200d]*";
#+end_src

** matching
#+begin_src java :noweb-ref Matching
Pattern TOKEN =
    Pattern.compile(String.join("|",
                                COMMENT,
                               // LITERAL
                                IDENTIFIER_NAME,
                                LINE_TERMINATOR,
                                PUNCTUATOR
                                ));
Matcher matcher = TOKEN.matcher(code);
List<String> matches = new ArrayList<String>();
while (matcher.find()) {
    String match = matcher.group();
    if (match.contains("/*") || match.contains("//")) {
        System.out.println("ignored");
        continue;
    }
    // System.out.println(matcher.start() + " " + matcher.end());

    matches.add(match);
}
#+end_src

** tokenizer_end
#+begin_src java :noweb-ref tokenizer_end
        return matches;
    }
}
#+end_src

#+begin_src java :tangle no
    if (matches.length == 0) {
        throw ParseException("Code could not be parsed.", matcher.end());
    }
#+end_src
